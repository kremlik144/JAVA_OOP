# Задача 1. Чтобы разблокировать телефон, пользователь может выбрать один из способов:
- Без пароля
- С пин-кодом (4-значное число)
- По отпечатку пальца (кодируется строкой)
- По распознаванию лица (кодируется строкой)

Программист написал класс Unlocker, в котором хранятся поля от всех способов сразу:

class Unlocker {

private int mode; // режим

private int pin; // на случай пин-кода

private String fingerprint; // на случай отпечатка пальца

private String faceID; // на случай лица

} 

Здесь нарушен принцип SRP: класс имеет несколько незаивисимых причин меняться.
Напишите решение, которое будет соответствовать SRP и OCP (мы хотим в будущем добавлять новые способы разблокировки).

### Пояснение к решению:
1. Запуск программы с файла Main.java
2. Папка Phone содержит класс Iphone который:
* соержит главный метод unlockPhone(), демонстрирующий работу, в зависимости от переданного в него режима разблокировки 
3. Папка Blockings содержит:
* абстрактный класс Unlocker<T> с обобщением, для реализации различных классов разблокировки
* классы FaceIDUnlocker, FingerprintUnlocker, PinUnlocker реализующие класс Unlocker<T> для разблокировки по лицу, отпечатку пальца и пин-коду соответственно


# Задача 2. Есть два самодельных класса коллекций:

ImmutableList<T> — коллекция, которая никогда ни при каких обстоятельствах не меняется. Методы:
• getSize ()
• get (int i)

MutableList<T> — коллекция, которая допускает изменения. Методы:
• getSize ()
• get (int i)
• set (int i, T newValue)
• add (T newValue)
• remove (T value)

Реализуйте такую схему наследования между двумя этими классами, которая будет соответствовать принципу подстановки Лисков.

### Пояснение к решению:
1. Запуск программы с файла Main.java
2. Классы ImmutableList<T> и MutableList<T> реализуют абстрактный класс Lists<T> и выполняют функции, указанные в задании 